from collections import defaultdict
from pathlib import Path
from typing import List, Tuple, Union

import pyradox
import pyradox.datatype as _pydt

from .paths import *

pyradox.Color = _pydt.Color
pyradox.Tree = _pydt.Tree

AUTO_GENERATED_HEADER = (
    "# =========================================================== #\n"
    "#            THIS FILE IS AUTOMATICALLY GENERATED!            #\n"
    "#  Any manual changes will be OVERWRITTEN upon regeneration!  #\n"
    "# =========================================================== #\n\n"
)


def convert_color(color: _pydt.Color) -> str:
    if color.colorspace == "rgb":
        r, g, b = color.channels
        return f"rgb {{ {r} {g} {b} }}"
    elif color.colorspace == "hsv":
        h, s, v = color.channels
        return f"hsv {{ {h:.2f} {s:.2f} {v:.2f} }}"
    else:
        raise ValueError(f"Unsupported color space: {color.colorspace}")


def convert_tree_to_blocks(
    tree: _pydt.Tree,
) -> List[Union[str, Tuple[str, List[object]]]]:
    blocks: List[Union[str, Tuple[str, List[object]]]] = []

    grouped: dict[str, list] = {}

    # Group repeated keys
    for key, value in tree.items():
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(value)

    for key, values in grouped.items():
        # All scalar values â†’ aggregate into one line
        if all(not isinstance(v, (_pydt.Tree, list)) for v in values):
            formatted_values = [
                f'"{v}"' if isinstance(v, str) else str(v) for v in values
            ]
            if len(formatted_values) == 1:
                blocks.append(f"{key} = {formatted_values[0]}")
            else:
                items = " ".join(formatted_values)
                blocks.append(f"{key} = {{ {items} }}")

        else:
            # Complex values: trees or lists
            for v in values:
                if isinstance(v, _pydt.Tree):
                    # Use the parent key as the tag, not the "tag" inside the tree
                    subblocks = convert_tree_to_blocks(v)
                    blocks.append((key, subblocks))
                elif isinstance(v, list):
                    for item in v:
                        if isinstance(item, _pydt.Tree):
                            # Again, parent key is used to avoid double nesting
                            subblocks = convert_tree_to_blocks(item)
                            blocks.append((key, subblocks))
                        else:
                            # Scalar inside a list
                            formatted = (
                                f'"{item}"' if isinstance(item, str) else str(item)
                            )
                            blocks.append(f"{key} = {formatted}")

    return blocks


def make_block(
    tag: str,
    lines: List[Union[str, Tuple[str, List[object]]]] | None = None,
    indent_level: int = 0,
    indent_str: str = "    ",
) -> str:
    if lines is None:
        lines = []

    prefix = indent_str * indent_level
    inner_prefix = prefix + indent_str

    parts: List[str] = [f"{prefix}{tag} = {{\n"]

    for line in lines:
        if isinstance(line, tuple) and len(line) == 2:
            subtag, sublines = line
            parts.append(make_block(subtag, sublines, indent_level + 1, indent_str))
        else:
            parts.append(f"{inner_prefix}{line}\n")

    parts.append(f"{prefix}}}\n")
    return "".join(parts)


def write_blocks(
    out_path: Path,
    blocks: Union[
        str,
        Tuple[str, List[object]],
        List[Union[str, Tuple[str, List[object]]]],
    ],
    mode: str = "w",
    encoding: str = "utf-8-sig",
    indent_str: str = "    ",
) -> Path:
    # normalize to a list of blocks
    if isinstance(blocks, (tuple, str)):
        blocks_list = [blocks]
    elif isinstance(blocks, list):
        blocks_list = blocks
    elif isinstance(blocks, _pydt.Tree):
        blocks_list = convert_tree_to_blocks(blocks)
    else:
        raise TypeError("blocks must be a str, a (tag, lines) tuple, or a list")

    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open(mode, encoding=encoding) as f:
        # --- header ---
        f.write(AUTO_GENERATED_HEADER)

        for block in blocks_list:
            if isinstance(block, tuple) and len(block) == 2:
                tag, lines = block
                f.write(make_block(tag, lines, indent_level=0, indent_str=indent_str))
                f.write("\n")
            else:
                s = str(block)
                f.write(s)
                if not s.endswith("\n"):
                    f.write("\n")
                if out_path.suffix not in (".yml", ".yaml"):
                    f.write("\n")

    return out_path


def write_culture_group_data(culture_data: list):
    blocks = [(culture_group["tag"], []) for culture_group in culture_data]
    out_path = iu_culture_groups / f"ir_culture_groups.txt"
    write_blocks(out_path, blocks)


def write_culture_data(culture_data: list):
    for culture_group in culture_data:
        blocks = []

        for culture in culture_group["cultures"]:
            lines = [
                f"color = {culture_group['color']}",
                f"tags = {{ {culture_group['graphical_culture']} }}",
                f"culture_groups = {{ {culture_group['tag']} }}",
            ]

            blocks.append((culture["tag"], lines))

        out_path = iu_cultures / f"{culture_group['tag']}.txt"

        write_blocks(out_path, blocks)


def write_religion_group_data(religion_data: list):
    blocks = [
        (
            "ir_religion_group",
            [
                "# Will probably need to change this manually later",
                f"color = rgb {{ 255 255 255 }}",
            ],
        )
    ]

    out_path = iu_religion_groups / f"ir_default.txt"

    write_blocks(out_path, blocks)


def write_religion_data(religion_data: list):
    blocks = [
        (
            religion["tag"],
            [
                f"color = {convert_color(religion['color'])}",
                f"group = ir_religion_group",
            ],
        )
        for religion in religion_data
    ]

    out_path = iu_religions / f"ir_religions.txt"

    write_blocks(out_path, blocks)


def write_country_setup(country_data: list, override_data: list):
    setup_dir_dict = defaultdict(list)

    # --- normal country setup ---
    for country in country_data:
        lines = [
            f"# {country['tag']} -> {ir_countries_dir.relative_to(ir_game)}/{country['setup_dir']}/{country['setup_file']}",
            f"color = {convert_color(country['color'])}",
            f"culture_definition = {country['culture']}",
            f"religion_definition = {country['religion']}",
        ]
        setup_dir_dict[country["setup_dir"]].append((country["tag"], lines))

    for setup_dir, country_blocks in setup_dir_dict.items():
        out_path = iu_countries / f"00_ir_{setup_dir}.txt"
        write_blocks(out_path, country_blocks)

    # --- overrides: COLLECT, THEN WRITE ONCE ---

    for path, countries in override_data.items():
        if path == "_default.txt":
            continue
        override_blocks = []
        for country in countries:
            lines = [
                f"# Override for {country['tag']}",
                f"color = {convert_color(country['color']) if isinstance(country['color'], _pydt.Tree) else country['color']}",
                f"culture_definition = {country['culture']}",
                f"religion_definition = {country['religion']}",
                f"is_historic = yes",
            ]
            override_blocks.append((country["tag"], lines))

        out_path = mod_root / path
        write_blocks(out_path, override_blocks)


def write_localisation_files(
    culture_data: list, religion_data: list, country_data: list
):
    culture_lines = [f"l_english:"]
    for culture_group in culture_data:
        culture_lines.append(f'  {culture_group["tag"]}: "{culture_group["name"]}"')
        culture_lines.append(
            f'  {culture_group["tag"]}_desc: "{culture_group["name_desc"]}"'
        )
        for culture in culture_group["cultures"]:
            culture_lines.append(f'  {culture["tag"]}: "{culture["name"]}"')

    religion_lines = [f"l_english:"]
    religion_lines.append(f'  ir_religion_group: "Ir religion group"')
    religion_lines.append(f'  ir_religion_group_ADJ: "Ir religion group"')
    religion_lines.append(f'  ir_religion_group_desc: "Ir religion group"')
    for religion in religion_data:
        religion_lines.append(f'  {religion["tag"]}: "{religion["name"]}"')
        religion_lines.append(f'  {religion["tag"]}_ADJ: "{religion["name_adj"]}"')
        religion_lines.append(f'  {religion["tag"]}_desc: "{religion["name_desc"]}"')

    country_lines = [f"l_english:"]
    for country in country_data:
        country_lines.append(f'  {country["tag"]}: "{country["name"]}"')
        country_lines.append(f'  {country["tag"]}_ADJ: "{country["name_adj"]}"')

    write_blocks(iu_localisation / "ir_cultures_l_english.yml", culture_lines)
    write_blocks(iu_localisation / "ir_religions_l_english.yml", religion_lines)
    write_blocks(iu_localisation / "ir_countries_l_english.yml", country_lines)


def write_coa_file(coa_data: _pydt.Tree):
    write_blocks(iu_prescripted_coa, coa_data)
