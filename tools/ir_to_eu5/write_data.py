import os
from collections import defaultdict
from pathlib import Path
from typing import List, Tuple, Union

import pyradox
import pyradox.datatype as _pydt

from .data import government_map
from .paths import *

pyradox.Color = _pydt.Color
pyradox.Tree = _pydt.Tree

AUTO_GENERATED_HEADER = (
    "# =========================================================== #\n"
    "#            THIS FILE IS AUTOMATICALLY GENERATED!            #\n"
    "#  Any manual changes will be OVERWRITTEN upon regeneration!  #\n"
    "# =========================================================== #\n\n"
)


def print_written(kind: str, out_path: Path) -> None:
    """Print a concise relative write message for `out_path`.

    `kind` should be a short label like 'file', 'JSON', 'CSV', or 'image'.
    """
    try:
        rel = os.path.relpath(str(out_path), start=str(mod_root))
    except Exception:
        rel = str(out_path)
    print(f"Writing {kind}: {rel}")


def convert_color(color: _pydt.Color) -> str:
    if color.colorspace == "rgb":
        r, g, b = color.channels
        return f"rgb {{ {r} {g} {b} }}"
    elif color.colorspace == "hsv":
        h, s, v = color.channels
        return f"hsv {{ {h:.2f} {s:.2f} {v:.2f} }}"
    else:
        raise ValueError(f"Unsupported color space: {color.colorspace}")


def convert_tree_to_blocks(
    tree: _pydt.Tree,
) -> List[Union[str, Tuple[str, List[object]]]]:
    blocks: List[Union[str, Tuple[str, List[object]]]] = []

    grouped: dict[str, list] = {}

    # Group repeated keys
    for key, value in tree.items():
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(value)

    for key, values in grouped.items():
        # All scalar values â†’ aggregate into one line
        if all(not isinstance(v, (_pydt.Tree, list)) for v in values):
            formatted_values = [
                f'"{v}"' if isinstance(v, str) else str(v) for v in values
            ]
            if len(formatted_values) == 1:
                blocks.append(f"{key} = {formatted_values[0]}")
            else:
                items = " ".join(formatted_values)
                blocks.append(f"{key} = {{ {items} }}")

        else:
            # Complex values: trees or lists
            for v in values:
                if isinstance(v, _pydt.Tree):
                    # Use the parent key as the tag, not the "tag" inside the tree
                    subblocks = convert_tree_to_blocks(v)
                    blocks.append((key, subblocks))
                elif isinstance(v, list):
                    for item in v:
                        if isinstance(item, _pydt.Tree):
                            # Again, parent key is used to avoid double nesting
                            subblocks = convert_tree_to_blocks(item)
                            blocks.append((key, subblocks))
                        else:
                            # Scalar inside a list
                            formatted = (
                                f'"{item}"' if isinstance(item, str) else str(item)
                            )
                            blocks.append(f"{key} = {formatted}")

    return blocks


def make_block(
    tag: str,
    lines: List[Union[str, Tuple[str, List[object]]]] | None = None,
    indent_level: int = 0,
    indent_str: str = "    ",
) -> str:
    if lines is None:
        lines = []

    prefix = indent_str * indent_level
    inner_prefix = prefix + indent_str

    parts: List[str] = [f"{prefix}{tag} = {{\n"]

    for line in lines:
        if isinstance(line, tuple) and len(line) == 2:
            subtag, sublines = line
            parts.append(make_block(subtag, sublines, indent_level + 1, indent_str))
        else:
            parts.append(f"{inner_prefix}{line}\n")

    parts.append(f"{prefix}}}\n")
    return "".join(parts)


def write_blocks(
    out_path: Path,
    blocks: Union[
        str,
        Tuple[str, List[object]],
        List[Union[str, Tuple[str, List[object]]]],
    ],
    mode: str = "w",
    encoding: str = "utf-8-sig",
    indent_str: str = "    ",
) -> Path:
    # normalize to a list of blocks
    if isinstance(blocks, (tuple, str)):
        blocks_list = [blocks]
    elif isinstance(blocks, list):
        blocks_list = blocks
    elif isinstance(blocks, _pydt.Tree):
        blocks_list = convert_tree_to_blocks(blocks)
    else:
        raise TypeError("blocks must be a str, a (tag, lines) tuple, or a list")

    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open(mode, encoding=encoding) as f:
        # --- header ---
        f.write(AUTO_GENERATED_HEADER)

        for block in blocks_list:
            if isinstance(block, tuple) and len(block) == 2:
                tag, lines = block
                content = make_block(tag, lines, indent_level=0, indent_str=indent_str)
                # Collapse accidental double-empty-brace sequences (e.g. "{ {} }")
                content = content.replace("{ {} }", "{}")
                f.write(content)
                f.write("\n")
            else:
                s = str(block)
                s = s.replace("{ {} }", "{}")
                f.write(s)
                if not s.endswith("\n"):
                    f.write("\n")
                if out_path.suffix not in (".yml", ".yaml"):
                    f.write("\n")

    print_written("file", out_path)
    return out_path


def write_culture_group_data(culture_data: list):
    blocks = [(culture_group["tag"], []) for culture_group in culture_data]
    out_path = iu_culture_groups / f"ir_culture_groups.txt"
    write_blocks(out_path, blocks)


def write_culture_data(culture_data: list):
    for culture_group in culture_data:
        blocks = []

        for culture in culture_group["cultures"]:
            lines = [
                f"color = {culture_group['color']}",
                f"tags = {{ {culture_group['graphical_culture']} }}",
                f"culture_groups = {{ {culture_group['tag']} }}",
            ]

            blocks.append((culture["tag"], lines))

        out_path = iu_cultures / f"{culture_group['tag']}.txt"

        write_blocks(out_path, blocks)


def write_religion_group_data(religion_data: list):
    blocks = [
        (
            "ir_religion_group",
            [
                "# Will probably need to change this manually later",
                f"color = rgb {{ 255 255 255 }}",
            ],
        )
    ]

    out_path = iu_religion_groups / f"ir_default.txt"

    write_blocks(out_path, blocks)


def write_religion_data(religion_data: list):
    blocks = [
        (
            religion["tag"],
            [
                f"color = {convert_color(religion['color'])}",
                f"group = ir_religion_group",
            ],
        )
        for religion in religion_data
    ]

    out_path = iu_religions / f"ir_religions.txt"

    write_blocks(out_path, blocks)


def write_country_setup(country_data: list, override_data: list):
    setup_dir_dict = defaultdict(list)

    # --- normal country setup ---
    for country in country_data:
        lines = [
            f"# {country['tag']} -> {ir_countries_dir.relative_to(ir_game)}/{country['setup_dir']}/{country['setup_file']}",
            f"color = {convert_color(country['color'])}",
            f"culture_definition = {country['culture']}",
            f"religion_definition = {country['religion']}",
        ]
        setup_dir_dict[country["setup_dir"]].append((country["tag"], lines))

    for setup_dir, country_blocks in setup_dir_dict.items():
        out_path = iu_countries / f"00_ir_{setup_dir}.txt"
        write_blocks(out_path, country_blocks)

    # --- overrides: COLLECT, THEN WRITE ONCE ---

    for path, countries in override_data.items():
        if path.name.endswith("_default.txt"):
            continue
        override_blocks = []
        for country in countries:
            lines = [
                f"# Override for {country['tag']}",
                f"color = {convert_color(country['color']) if isinstance(country['color'], _pydt.Tree) else country['color']}",
                f"culture_definition = {country['culture']}",
                f"religion_definition = {country['religion']}",
                f"is_historic = yes",
            ]
            override_blocks.append((country["tag"], lines))

        out_path = mod_root / path
        write_blocks(out_path, override_blocks)


def write_localisation_files(
    culture_data: list, religion_data: list, country_data: list
):
    culture_lines = [f"l_english:"]
    for culture_group in culture_data:
        culture_lines.append(f'  {culture_group["tag"]}: "{culture_group["name"]}"')
        culture_lines.append(
            f'  {culture_group["tag"]}_desc: "{culture_group["name_desc"]}"'
        )
        for culture in culture_group["cultures"]:
            culture_lines.append(f'  {culture["tag"]}: "{culture["name"]}"')

    religion_lines = [f"l_english:"]
    religion_lines.append(f'  ir_religion_group: "Ir religion group"')
    religion_lines.append(f'  ir_religion_group_ADJ: "Ir religion group"')
    religion_lines.append(f'  ir_religion_group_desc: "Ir religion group"')
    for religion in religion_data:
        religion_lines.append(f'  {religion["tag"]}: "{religion["name"]}"')
        religion_lines.append(f'  {religion["tag"]}_ADJ: "{religion["name_adj"]}"')
        religion_lines.append(f'  {religion["tag"]}_desc: "{religion["name_desc"]}"')

    country_lines = [f"l_english:"]
    for country in country_data:
        country_lines.append(f'  {country["tag"]}: "{country["name"]}"')
        country_lines.append(f'  {country["tag"]}_ADJ: "{country["name_adj"]}"')

    write_blocks(iu_localisation / "ir_cultures_l_english.yml", culture_lines)
    write_blocks(iu_localisation / "ir_religions_l_english.yml", religion_lines)
    write_blocks(iu_localisation / "ir_countries_l_english.yml", country_lines)


def write_coa_file(coa_data: _pydt.Tree):
    write_blocks(iu_prescripted_coa, coa_data)


def _build_location_to_province_map(tree) -> dict:
    """Build a mapping from location -> province key by walking the eu5 map tree.

    The tree is a nested dict/Tree structure where the smallest keys are location
    identifiers and their parent is the province (the second-smallest tier).
    """
    mapping: dict = {}

    def walk(node, parent=None):
        # pyradox.Tree behaves like dict
        if isinstance(node, (_pydt.Tree, dict)):
            for k, v in node.items():
                if isinstance(v, (_pydt.Tree, dict)):
                    # k is a grouping key (could be province or higher); recurse
                    walk(v, k)
                elif isinstance(v, list):
                    # list of scalar locations or subtrees
                    for item in v:
                        if isinstance(item, (_pydt.Tree, dict)):
                            walk(item, k)
                        else:
                            mapping[str(item)] = k
                else:
                    # leaf value: k is likely a location name, parent is province
                    mapping[str(k)] = parent if parent is not None else k
        elif isinstance(node, list):
            for item in node:
                walk(item, parent)

    walk(tree, None)
    return mapping


def write_blocks_with_comments(
    out_path: Path,
    blocks: List[Tuple[str, List[object]]],
    comment_tags: set[str] | None = None,
    mode: str = "w",
    encoding: str = "utf-8",
    indent_str: str = "    ",
) -> Path:
    if comment_tags is None:
        comment_tags = set()

    def render_block(tag: str, lines: list, level: int = 0) -> list[str]:
        prefix = indent_str * level
        inner_prefix = indent_str * (level + 1)
        output: list[str] = []

        # Check if we need to comment out this entire block
        comment_block = tag in comment_tags

        # Opening line
        open_line = f"{prefix}{tag} = {{"
        if comment_block:
            open_line = "# " + open_line
        output.append(open_line)

        for line in lines:
            if isinstance(line, tuple) and len(line) == 2:
                subtag, sublines = line
                sublines_rendered = render_block(subtag, sublines, level + 1)
                if comment_block:
                    # Prefix every line of sub-block
                    sublines_rendered = [
                        f"# {l}" if not l.startswith("#") else l
                        for l in sublines_rendered
                    ]
                output.extend(sublines_rendered)
            else:
                l = f"{inner_prefix}{line}"
                if comment_block:
                    l = "# " + l if not l.startswith("#") else l
                output.append(l)

        # Closing brace
        close_line = f"{prefix}}}"
        if comment_block:
            close_line = "# " + close_line
        output.append(close_line)

        return output

    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open(mode, encoding=encoding) as f:
        for block in blocks:
            if isinstance(block, tuple) and len(block) == 2:
                tag, lines = block
                rendered_lines = render_block(tag, lines, level=0)
                f.write("\n".join(rendered_lines) + "\n")
            else:
                # raw string block
                s = str(block)
                f.write(s)
                if not s.endswith("\n"):
                    f.write("\n")

    print_written("file", out_path)
    return out_path


def write_10_countries(ten_countries_data, country_data, eu5_map_data):
    country_map = {country["tag"]: country for country in country_data}
    blocks = []
    comment_tags = set()

    for country in country_data:
        tag = country["tag"]
        government_type = government_map[country_map[tag]["government"]]

        base = ten_countries_data.get(tag, {})
        base_government = base.get("government", {})
        value = base.get("own_control_core", [])

        # Normalize to a list
        if value is None:
            locations = []
        else:
            locations = value if isinstance(value, list) else [value]

        country_name = country.get("name", tag)
        ruler = base_government.get("ruler", "random")
        gov_lines = [f"ruler = {ruler}", f"type = {government_type}"]

        # Initialize lines
        lines: list = []

        # Start with country comment
        lines.append(f"# {country_name}")
        if not locations:
            comment_tags.add(tag)

        # Build mapping location -> province
        location_to_province = (
            _build_location_to_province_map(eu5_map_data)
            if eu5_map_data is not None
            else {}
        )

        if locations:
            # Group locations by province
            prov_map: dict[str, list] = {}
            for loc in locations:
                key = str(loc)
                prov = location_to_province.get(key, "unknown")
                prov_map.setdefault(prov, []).append(key)

            own_sublines: list[str] = []
            for prov, locs in sorted(prov_map.items()):
                own_sublines.append(f"# {prov}")
                own_sublines.append(" ".join(str(x) for x in locs))

            lines.append(("own_control_core", own_sublines))
        else:
            # Empty block, leave own_control_core for manual fill
            lines.append("own_control_core = { }")

        # Government sub-block
        lines.append(("government", gov_lines))

        # Includes
        raw_include = base.get("include", [])
        if raw_include is None:
            include_items = []
        else:
            include_items = (
                raw_include if isinstance(raw_include, list) else [raw_include]
            )

        if "expl_imperator_rome" not in include_items:
            include_items.insert(0, "expl_imperator_rome")

        # Only quote include items
        for x in include_items:
            lines.append(f'include = "{x}"')

        # Other fields
        rank = base.get("country_rank", "rank_county")
        lines.append(f"country_rank = {rank}")
        capital = base.get("capital", "REPLACE_ME")
        lines.append(f"capital = {capital}")

        # Add block
        blocks.append((tag, lines))

    # Wrap everything inside countries = { countries = { ... } }
    nested = ("countries", [("countries", blocks)])
    # Insert current age line before countries so it's written at top-level
    top_line = "current_age = age_1_traditions"
    write_blocks_with_comments(
        iu_10_countries, [top_line, nested], comment_tags=comment_tags
    )
